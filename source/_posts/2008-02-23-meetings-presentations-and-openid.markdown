---
comments: true
date: '2008-02-23 00:13:12'
layout: post
slug: meetings-presentations-and-openid
status: publish
title: Meetings, Presentations, and OpenID
wordpress_id: '105'
categories:
- personal
tags:
- talks
- openid
---

So, I've obviously failed in terms of trying to make more posts as I had said I would. But, I'm so busy with everything right now that I don't have much time to sit down and make lengthy (and frequent postings). Heck, even some of the regular events that I've been trying to start up at work (such as the Weekly Digest) has turned out to be not so weekly because I haven't been able to schedule them. However, it's about time that I give an update on my life situation and then a short tech talk on a really cool idea that has been around, but I haven't started using until now.

<h2>Meetings</h2>

At CIS, my work load has finally diminished from what it had been the previous semester. Last semester (for roughly the entire duration of the semester) I had a schedule timeline that was roughly 8 rows long (ie: I had to split my time evenly across 8 different projects). This was inefficient, but I brought it on myself because I like to be involved in many different things. I was one who was responsible for the maintenance of a web service we use in-house that I was looking forward to rewriting using the .Net WCF model and was also involved in several different initiative programs to help improve the quality of work that we put out from Customer Applications. These initiatives put me in the meeting room with my managers quite often as we discussed the importance and various aspects of how Customer Applications does business. It got me really great exposure in terms of what we actually are supposed to be doing and gave me better insight on how to plan for change. But, the meetings ended up bogging me down so much that it felt that roughly 75-80% of my time was spent doing business-related work (which included customer interaction) and then 20-25% of my time was spent coding (again, it felt like this, but may not have been the literal case).

Now, mind you, I have a very strong passion to want to see Customer Applications succeed. Everyone was in acknowledgment that change was necessary and that we are behind in the times of development strategies. However, as the result of a project that failed miserably last semester, we have to be extra cautious and be that much more attentive to strategic planning to help ensure that we succeed. This I'm in complete agreement with: you cannot expect to change things overnight and have it work. Such a mindset will surely lead to dramatic failure, which is something we want to avoid. I did a lot of research on Gartner for the information that I'm looking for and found that typical business plans and timelines project that these changes take anywhere between 1 and 3 years to occur and bring chaos to the group. This makes sense, especially the chaos part because of the fact that there's almost complete change occurring, and it's very hard for everyone to deal with this. 

Fortunately and unfortunately, I never have written a business plan for something like this. I was expecting to only take a couple of weeks to have it, but having to do research, analysis, and come up with a sound business plan is difficult when you have other customer projects going on at the same time, makes it extremely difficult. I had been working on the business plan for a few weeks (roughly until the beginning of February) when things changed. 

We managed to convince a customer of ours that everything they wanted to get completed would not be so unless they upped their support contract time. We recommended throwing an additional 40 hours a week at their project, but they could only find the budget for an additional 20 hours a week. Because I was the technical and project leader for this customer, and the one with the most available time (because it was a lot of overhead), I had my time increased from 10 hours a week to 30 hours a week for this customer. This knocked off probably at least 4 rows on my schedule, putting me at 4 different projects to maintain. 

Then, just last week, I managed to finish another customer project that had gone on longer than had been anticipated. Their project involved some upgrades that made the application more secure and robust as well as some aesthetic changes they had requested. However, they were an ad-hoc customer, and could only be worked on when I had applicable time, which had not been much at all last semester. This eliminated another row on my schedule, but was quickly replaced by another customer coming back and asking for contracted PHP support. 

In short, what has happened is my schedule has become more blocky, meaning that it's not spread so thin. I actually really enjoy this because then I can dedicate good chunks of time throughout the day and make progress on projects and other work as necessary. Unfortunately, most of my overhead time that was allowing me to develop the business plan to help revamp the way Customer Applications works is now on standby because I have to work on customer projects. Further, the managers that were helping me are also extremely busy managing their employees and working on other projects to help further this business plan. In short, this leaves Customer Applications in the state it is for however much longer. I only wish that our Associate Director would realize that we've maxed out our resources and that more positions should be opened within our group so that we could relieve the stress on everyone. But, because I'm not privileged to the information that goes on at the high-level, I don't know whether he sees this and can't hire new employees for other reasons, but the frustration of projects being shifted around and the realization that more projects are quickly on their way, but no relief, is starting to show among the developers.

<h2>Presentations</h2>

Well, I gave a couple of additional presentations recently at <a href="http://www.barcamptexas.com" target="_blank">BarCamp Texas</a>. I have to give kudos to Cody Bailey and the crew at the Creative Space, as well as everyone else that helped to put on this event, as it was truly an amazing informal conference that I will certainly be attending in the future. For those unfamiliar (and too lazy to check out the link), the gist of the event is technical enthusiasts, designers, and those whom are creative thinkers gather and create a schedule of talks/presentations they want to give by writing the name of the talk on a whiteboard. This is done on the day of the event, so it's very impromptu (if the speaker hasn't prepared for it ahead of time, which most seemed to). Then, the events begin and it's kind of like any other conference, where there's 30 minutes dedicated to a talk/presentation and then they move on. The idea is to network everyone together and get creative thinking and discussions going on whatever topic they feel like.

I ended up giving two talks. One was with <a href="http://www.toosweettobesour.com/" target="_blank">Daniel Cousineau</a> over <a href='http://www.chrisweldon.net/wp-content/uploads/2008/02/php-and-mvc.pdf' title='PHP and MVC'>PHP and MVC</a>. This particular talk had a good turnout with many people posing different questions. Mind you, I won't get mad at Daniel for practically dominating the talk, but I pretty much was in agreement with everything. I managed to throw in points that he missed out on, or was able to extend many of the sections he was talking about, but felt bad because we were unable to provide a code sample to our readers. 

The second talk (which did not contain a slide set, as it was strictly a code sample and talk) was given by both myself and Ben Floyd. The talk was over LINQ, expanded as Language INtegrated Query. It's a new feature in the .Net 3.5 Framework release that brings a psuedo-ORM (Object-Relational-Mapping) model to .Net applications. Further, it helps developers write strongly-typed and secure SQL queries in their code, so they get compile-time notifications of changes instead of runtime errors. However, it's not just for data access, but also extends to XML and iterating over in-memory sets of data (anything that implements the IEnumerable interface). Short of having to convince developers to look at it, it's a damn awesome technology and I give kudos to Microsoft for implementing it. I will attempt to post the code samples online, but it's a bit difficult because the project was geared towards actually showing you how to convert old code to new code. Furthermore, most people won't really be able to utilize the code samples because you have to have Visual Studio 2008 to open the solution. However, this presents an interesting idea...maybe a Camtasia video? Perhaps. 

In any case, getting to finally present in front of two audiences and share the knowledge that I have (and put myself forward as an upcomping expert in these fields) was a thrilling experience. One of the goals I've set for myself is to be able to become one of those that gives frequent talks at conferences and user groups around the world. I want to be an author of a software development book that breaks new grounds and puts me in there with the high-rollers (really just the highly technically proficient individuals). This is one of the things I aspire to do, because I love to be in a position to share my knowledge with everyone. Mind you, it's not my intent to push down onto everyone the idea that "I know much more than you.". Rather, my determination is driven by the desire to see everyone succeed. I've seen so many software developers and so many applications that are pieces of shit because people don't really know all there is to know about software development. However, with enough of a push and enough knowledge sharing, we may be able to start seeing the rapid increase in software quality quicker than we currently are seeing.

<h2>OpenID</h2>

Okay, because this post is so long already, I'll try to keep this short. I didn't just stumble onto this technology, as I had known about it for quite some time. However, I just never had the opportunity to look at it because I was so busy learning other things. However, now that I've had the chance to play with it, the technology and idea is quite thrilling, really.

In a nutshell, OpenID is all about decentralization of authentication (AuthN) and consolidation of identity. Woah, what? Lemme explain further. If you go to 5 completely non-interrelated web sites that are publicly available, how many usernames, passwords, and accounts do you have to manage? Usually the answer is 5 usernames, 5 passwords, 5 accounts. This starts to get really old as that number goes up. It becomes particularly hard when you register for a site you hardly visit, and then have to remember that god forsaken username/password combination for it. Another problem for this model is that sometimes your typical username is already taken at these websites. This is where we start to see derivatives such as 'kittysmear1432' or 'dragonsblood87392', as examples. So, when you usually expect to only have to remember passwords for sites, you now may have to remember "what's that number I put at the end of my username"?

OpenID combats both of these problems. With OpenID, the decentralization of AuthN means that you can have an unlimited number of what we call identity providers on the internet. These providers don't share information with one another (like some big centralized authentication system would) and are all really individuals. You can run your own identity provider if you'd like, but there are many others that have robust infrastructures that you should probably consider. In fact, you may be using services online that already are providers (such as <a href="http://www.livejournal.com/">LiveJournal</a>, <a href="http://www.wordpress.com/">Wordpress</a>, etc.). The idea is that you register for an account with only one provider (again, LiveJournal, Wordpress, SignOn, MyOpenID, etc.). When you register for an OpenID with them, this provider gives you, effectively, your identity for the internet. This is realized through a URI (URL, however you like to call it). A typical URI will look like "chris.myopenid.com". 

So, now that you have your identity established on the internet, how do you use it? It's simple. You go to your favorite website. When you're asked to login, you don't do the typical type your username and password to get access. Instead, you give the web site that URI and nothing more, then click login. What happens is the website you are trying to login to takes the URI and sends you to the identity provider you got it from. The identity provider asks you to login and verify that you are who you purport to be. If you can provide your username and password in this one central location (where every OpenID web site sends you to), then you login to the web site without a problem.

Let me take this further from a technical point-of-view and actually present it on a very simplified level. Imagine you go to your local DMV office to get yourself a driver's license, which is typically used to affirm your identity. The state in which you reside (which operates this DMV) is the Identity Provider. They provide you with a card (equivalent to the URI) that identifies who you are. Suppose for arguments sake, however, that the card contains no real identifying information (such as Date of Birth, etc.) Now, imagine you are trying to get into a location which requires you to have a valid ID (say a bar). The doorman would look at your driver's license and would then call the DMV to ask if the person standing in front of him is who he claims he or she is. The doorman would hand the phone then to you which the DMV officer would ask you for a piece of information that was not on the card (say SSN # and Date of Birth, which we said was stripped from the card). Also assume that the doorman cannot hear the conversation you are having. You hand the phone back to the doorman, and the DMV proceeds to state that you are who you say you are. The doorman rights your card ID # (URI) down on a list for future reference. This is how OpenID works, in very simplistic terms.

Now, the other thing that OpenID helps combat is this whole username and identity issue. Because only one URI can ever identify one person, there's no having to fight for usernames at multiple sites. Your OpenID URI will be guaranteed to be unique at different web sites, unless your identity has been compromised. Additionally, OpenID makes it possible for you to claim resources or pieces of information on the internet that are your own, and actually be able to prove that it is yours! You can now identify blogs, and other pages (perhaps even MySpace, Facebook, and other social networking sites in the future) as your own by adding your OpenID URI and identity provider address into the page itself. Now, these things are not visible to the naked eye, but are done through 2 lines of HTML which are rather simple. However, this is a topic of another conversation, but know that you can finally genuinely mark a blog as your own and be able to prove to others that it is, if requested. This enables aliasing of identities, so you can go back to having multiple names for yourself. The difference than how its done now, however, is that all aliases actually tie back to a parent name, as opposed to being completely anonymous aliases.  

I'm out of time for today. Feel free to comment, but make sure you login with your OpenID account first!
